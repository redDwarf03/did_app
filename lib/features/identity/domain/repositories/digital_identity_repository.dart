import 'package:flutter/foundation.dart'; // For Uint8List if needed later
// Import models for IdentityDetails and potentially CreationResult
import 'package:did_app/features/identity/domain/models/user_identity_details.dart';
import 'package:did_app/features/identity/domain/models/service_creation_result.dart';
import 'package:archethic_wallet_client/archethic_wallet_client.dart'; // Import AWC types

abstract class DigitalIdentityRepository {
  /// Retrieves the connected user's identity details from the wallet.
  /// Returns null if not connected or details are unavailable.
  /// This might observe AWC's state or make a specific request.
  Stream<UserIdentityDetails?>
      watchCurrentUserIdentity(); // Changed to Stream for reactivity

  /// Requests the external wallet to add a service specific to this dApp.
  /// [serviceName] : A unique name for the service (e.g., 'did_app_profile').
  /// [derivationPath] : Optional. If not provided, a default might be used or generated by the wallet.
  /// Throws an exception if the operation fails or is rejected by the user.
  Future<ServiceCreationResult> addDappService({
    required String serviceName,
    String? derivationPath, // e.g., "m/650'/did_app_profile/0"
  });

  /// Checks if the dApp-specific service already exists for the current user.
  /// This might involve fetching the keychain/DID details and checking the service list.
  /// [serviceName] : The name of the service to check.
  Future<bool> checkDappServiceExists({required String serviceName});

  /// Requests the external wallet to sign a generic transaction payload.
  /// Used for operations like creating DATA transactions for VCs.
  /// [transactionJsonData]: The JSON representation of the transaction *before* signing.
  /// Returns the result containing the signed transaction details or failure info.
  Future<dynamic> requestTransactionSignature(
    Map<String, dynamic> transactionJsonData,
  );

  /// Derives and returns the expected blockchain address for a given service name.
  /// Returns null if the address cannot be derived (e.g., keychain not available).
  Future<String?> getExpectedServiceAddress(String serviceName);

  // Optional: Methods specifically for Verifiable Credentials management via AWC
  // Future<VerifiableCredential> createSelfIssuedVC(Map<String, dynamic> claims, String serviceName);
  // Future<VerifiablePresentation> createPresentation(List<VerifiableCredential> vcs, String challenge);
  // Future<void> storeVC(VerifiableCredential vc); // Might involve requestTransactionSignature
  // Future<List<VerifiableCredential>> getStoredVCs();
}
